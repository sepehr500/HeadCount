{"Name":"Couchbase Lite for .NET","Id":2494,"Alias":"couchbase-lite-net","Description":"**Couchbase Lite** is the worldâ€™s first and only full featured, flexible, mobile JSON database that runs locally on the device and is built from the ground up for mobile devices. We have native support for Objective-C, Java and now we are in Beta for .NET.\n\n# Couchbase Mobile\n\nCouchbase Lite is part of our comprehensive mobile stack, Couchbase Mobile. Couchbase Mobile includes:\n\n* **Couchbase Lite:** our embedded NoSQL database built for all major platforms\n* **Sync Gateway:** a sync tier that manages all of the synchronization (including user authentication, access control, data filtering and validation) between the mobile device and the server on the cloud. Sync Gateway makes it possible to quickly and easily code the synchronization between the mobile device and the server in the cloud with a page of code\n* **Couchbase Server:** our enterprise-ready, document-oriented scalable NoSQL database\n\nCouchbase Mobile enables mobile application developers to create highly responsive, datacentric applications that are always-available regardless of network connectivity. Get more info about Sync Gateway and Couchbase Server at our website:\n\n* [Couchbase Sync Gateway Overview](http://www.couchbase.com/mobile#sync-gateway) \n* [Couchbase Server Overview](http://www.couchbase.com/couchbase-server/overview)\n\n# Platform Support\n\nCouchbase Lite .NET for Xamarin currently supports deployment to iOS 6+, Android 2.2+ and .NET 4.5 targets.\n\n# Manuals\n\nLearn how Couchbase Lite and Sync Gateway works at our [Couchbase Mobile Developer portal](http://developer.couchbase.com/mobile/index.html).\n","Version":"1.2.0.3","Summary":"A lightweight, document-oriented (NoSQL), syncable database engine.","QuickStart":"# Getting Started with Couchbase\n\nYou\u0027ll probably create a new document when the user creates a persistent data item in your app, such as a reminder, a photograph or a high score. To save this, you\u0027ll construct a JSON-compatible representation of the data, then instantiate a new `Document` and save the data to it.\n\nHere\u0027s an example from Grocery Sync:\n\n```\n    var vals =  new Dictionary\u003cString,Object\u003e {\n        { \"text\" , value },\n        { \"check\" , false },\n        { \"created_at\" , jsonDate }\n    };\n```\n\nNext, ask the Database (instantiated when you initialized Couchbase Lite, remember?) for a new document. This doesn\u0027t add anything to the database yet; just like the New command in a typical Mac or Windows app, the document won\u0027t be stored on disk until you save some data into it. Continuing from the previous example:\n\n```\n    var doc = Database.CreateDocument();\n```\n\n## Saving A Document\n\nFinally save the contents to the document:\n\n```\ntry {\n  doc.PutProperties (vals);\n} catch(CouchbaseLiteException) {\n  throw new ApplicationException(\"Failed to save a new Document\");\n}\n```\n\n## Reading A Document\n\nIf later on you want to retrieve the contents of the document, you\u0027ll need to obtain the `Document` object representing it, then get the contents from that object.\n\nThere are two ways to get the `Document`:\n\n 1. You might know its ID (maybe you kept it in memory, maybe you got it from `NSUserDefaults` or even from a property of another document), in which case you can call `database.GetExistingDocument()`.\n 2. Or you might be iterating the results of a view query (or `AllDocument`, which is a special view), in which case you can get it from the `QueryRow`\u0027s `document` property.\n\nThen to get the document\u0027s contents, access its `Properties` property:\n\n```\n\tDocument doc = this.Database.GetExistingDocument(documentID);\n\tIDictionary\u003cstring,object\u003e contents = doc.Properties;\n  var text = (string) doc.Properties[\"text\"];\n  var checked = (bool) doc.Properties[\"check\"];\n```\n\nYou might be wondering which of these lines actually hits the database. The answer is that the `Document` starts out empty and loads its contents on demand, then caches them in memory; so it\u0027s the call to `document.Properties` that does it. Afterwards, getting properties is as cheap as a dictionary lookup. (For this reason it\u0027s best not to keep references to huge numbers of `Document` objects, or you\u0027ll end up storing all their contents in memory. Instead, rely on queries to look up documents as you need them.)\n\n## Updating A Document\n\nUpdating a document is trivial: You just call `PutProperties` again.\n\nOK, it\u0027s not quite that trivial. Remember the dry theoretical discussion of Multiversion Concurrency Control (MVCC) back in section 2? Here\u0027s where it gets real. When you update a document, Couchbase Lite wants to know _which revision you updated_, so it can stop you if there were any updates in the meantime. (Otherwise, you would wipe out those updates by overwriting them.) I\u0027ll get into update-conflict handling in a little bit; for now, just realize that Couchbase Lite wants to see that `_rev` property in the properties you\u0027re putting.\n\nFortunately this is painlessly accomplished, since the `_rev` property was already in the dictionary you got from the `Document`. So all you need to do is _modify the properties dictionary_ and hand back the modified dictionary, which still contains the `_rev` property, to `PutProperties`\n\n```\n    var newProperties = new Dictionary\u003cString, Object\u003e(doc.Properties);\n\tnewProperties[\"tag\"] = 4567;\n```\n\n`newProperties` is now a copy of the existing document (including the important `_rev` property), with the value of the `checked` property toggled.\n\nFinally you save the document the same way you did when you created it:\n\n```\n    SavedRevision newVersion = null;\n    try {\n      newVersion = doc.PutProperties(newProperties);\n    } catch(CouchbaseLiteException) {\n      ShowErrorAlert(\"Couldn\u0027t update the item.\");\n    }\n```\n\nAlternatively, you can take an easier route and use the `Update()` method.  This works on a similar basis to `PutProperties` but will retry in the event of a conflict so you don\u0027t need to worry about including the `_rev` item.  It will look something like this:\n\n```\n    SavedRevision newVersion = doc.Update(rev =\u003e\n    {\n      var props = rev.UserProperties;\n      // Edit props\n      rev.SetUserProperties(props);\n\n      return true;\n    });\n```\n\n## Deleting A Document\n\nDeleting is a lot like updating; instead of calling `PutProperties()` you call `Delete()`. Here\u0027s the sample code, which should be familiar looking by now:\n\n```\n    doc.Delete();\n    if (!doc.Deleted) ...        \n```\n","Hash":"f2eff5a184bbabfffced4ae71bce9abf","TargetPlatforms":["ios","ios-unified","android"],"TrialHash":null}