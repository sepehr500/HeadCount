{"Name":"Couchbase Lite for .NET","Id":999,"Alias":"couchbase-lite-net","Description":"**Couchbase Lite** is the worldâ€™s first and only full featured, flexible, mobile JSON database that runs locally on the device and is built from the ground up for mobile devices. We have native support for Objective-C, Java and now we are in Beta for .NET.\n\n# Couchbase Mobile\n\nCouchbase Lite is part of our comprehensive mobile stack, Couchbase Mobile. Couchbase Mobile includes:\n\n* **Couchbase Lite:** our embedded NoSQL database built for all major platforms\n* **Sync Gateway:** a sync tier that manages all of the synchronization (including user authentication, access control, data filtering and validation) between the mobile device and the server on the cloud. Sync Gateway makes it possible to quickly and easily code the synchronization between the mobile device and the server in the cloud with a page of code\n* **Couchbase Server:** our enterprise-ready, document-oriented scalable NoSQL database\n\nCouchbase Mobile enables mobile application developers to create highly responsive, datacentric applications that are always-available regardless of network connectivity. Get more info about Sync Gateway and Couchbase Server at our website:\n\n* [Couchbase Sync Gateway Overview](http://www.couchbase.com/mobile#sync-gateway) \n* [Couchbase Server Overview](http://www.couchbase.com/couchbase-server/overview)\n\n# Platform Support\n\nCouchbase Lite .NET for Xamarin currently supports deployment to iOS 6+, Android 2.2+ and .NET 4.5 targets.\n\n# Manuals\n\nLearn how Couchbase Lite and Sync Gateway works at our [Couchbase Mobile Developer portal](http://developer.couchbase.com/mobile/index.html).\n","Summary":"A lightweight, document-oriented (NoSQL), syncable database engine.","Version":"1.2","QuickStart":"# Getting Started with Couchbase\n\nYou'll probably create a new document when the user creates a persistent data item in your app, such as a reminder, a photograph or a high score. To save this, you'll construct a JSON-compatible representation of the data, then instantiate a new `Document` and save the data to it.\n\nHere's an example from Grocery Sync:\n\n```\n    var vals =  new Dictionary<String,Object> {\n        { \"text\" , value },\n        { \"check\" , false },\n        { \"created_at\" , jsonDate }\n    };\n```\n\nNext, ask the Database (instantiated when you initialized Couchbase Lite, remember?) for a new document. This doesn't add anything to the database yet; just like the New command in a typical Mac or Windows app, the document won't be stored on disk until you save some data into it. Continuing from the previous example:\n\n```\n    var doc = Database.CreateDocument();\n```\n\n## Saving A Document\n\nFinally save the contents to the document:\n\n```\ntry {\n  doc.PutProperties (vals);\n} catch(CouchbaseLiteException) {\n  throw new ApplicationException(\"Failed to save a new Document\");\n}\n```\n\n## Reading A Document\n\nIf later on you want to retrieve the contents of the document, you'll need to obtain the `Document` object representing it, then get the contents from that object.\n\nThere are two ways to get the `Document`:\n\n 1. You might know its ID (maybe you kept it in memory, maybe you got it from `NSUserDefaults` or even from a property of another document), in which case you can call `database.GetExistingDocument()`.\n 2. Or you might be iterating the results of a view query (or `AllDocument`, which is a special view), in which case you can get it from the `QueryRow`'s `document` property.\n\nThen to get the document's contents, access its `Properties` property:\n\n```\n\tDocument doc = this.Database.GetExistingDocument(documentID);\n\tIDictionary<string,object> contents = doc.Properties;\n  var text = (string) doc.Properties[\"text\"];\n  var checked = (bool) doc.Properties[\"check\"];\n```\n\nYou might be wondering which of these lines actually hits the database. The answer is that the `Document` starts out empty and loads its contents on demand, then caches them in memory; so it's the call to `document.Properties` that does it. Afterwards, getting properties is as cheap as a dictionary lookup. (For this reason it's best not to keep references to huge numbers of `Document` objects, or you'll end up storing all their contents in memory. Instead, rely on queries to look up documents as you need them.)\n\n## Updating A Document\n\nUpdating a document is trivial: You just call `PutProperties` again.\n\nOK, it's not quite that trivial. Remember the dry theoretical discussion of Multiversion Concurrency Control (MVCC) back in section 2? Here's where it gets real. When you update a document, Couchbase Lite wants to know _which revision you updated_, so it can stop you if there were any updates in the meantime. (Otherwise, you would wipe out those updates by overwriting them.) I'll get into update-conflict handling in a little bit; for now, just realize that Couchbase Lite wants to see that `_rev` property in the properties you're putting.\n\nFortunately this is painlessly accomplished, since the `_rev` property was already in the dictionary you got from the `Document`. So all you need to do is _modify the properties dictionary_ and hand back the modified dictionary, which still contains the `_rev` property, to `PutProperties`\n\n```\n    var newProperties = new Dictionary<String, Object>(doc.Properties);\n\tnewProperties[\"tag\"] = 4567;\n```\n\n`newProperties` is now a copy of the existing document (including the important `_rev` property), with the value of the `checked` property toggled.\n\nFinally you save the document the same way you did when you created it:\n\n```\n    SavedRevision newVersion = null;\n    try {\n      newVersion = doc.PutProperties(newProperties);\n    } catch(CouchbaseLiteException) {\n      ShowErrorAlert(\"Couldn't update the item.\");\n    }\n```\n\nAlternatively, you can take an easier route and use the `Update()` method.  This works on a similar basis to `PutProperties` but will retry in the event of a conflict so you don't need to worry about including the `_rev` item.  It will look something like this:\n\n```\n    SavedRevision newVersion = doc.Update(rev =>\n    {\n      var props = rev.UserProperties;\n      // Edit props\n      rev.SetUserProperties(props);\n\n      return true;\n    });\n```\n\n## Deleting A Document\n\nDeleting is a lot like updating; instead of calling `PutProperties()` you call `Delete()`. Here's the sample code, which should be familiar looking by now:\n\n```\n    doc.Delete();\n    if (!doc.Deleted) ...        \n```\n","Hash":"f41cc04e88d9339bbb6fb22a95a1124e","TargetPlatforms":["mobile"],"TrialHash":null}